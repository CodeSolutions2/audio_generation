<!DOCTYPE html>
<html>
<head></head>
<body>    

<h1>Generate white noise</h1>
<ol type="A">
	<li>Click on filter_noise to play white noise.</li>
</ol>


<div id="data_display" style="display:block; text-align: left; width: 600px;"></div>
	
<button id="play_filter_noise_way0" onclick="play_filter_noise_way0()" style="display:block">play_filter_noise_way0</button>
<button id="play_filter_noise_way1" onclick="play_filter_noise_way1()" style="display:block">play_filter_noise_way1</button>

	
<script>

// -----------------------------------------------

async function play_filter_noise_way0() {

	const audioElement = await create_an_audioElement();

	// -------------------
	
	const [audioContext, WhiteNoise_AudioBuffer, WhiteNoiseData_TypeArray] = await create_audio_data();
	// WhiteNoise_AudioBuffer:  AudioBuffer { sampleRate: 48000, length: 96000, duration: 2, numberOfChannels: 2 }
	// WhiteNoiseData_TypeArray: buffer, byteLength, byteOffset, length
	
	// -------------------
	
	// Array is given to sourceElement
	var sourceElement = audioContext.createBufferSource(audioElement);
	sourceElement.buffer = WhiteNoise_AudioBuffer;
	sourceElement.id = "sourceElement_id";			
	sourceElement.connect(audioContext.destination);

	// -------------------
	
	// Allows audio to be changed(play, pause, etc) from audioElement
	// audioElement.appendChild(sourceElement);
	// RESULT: Node append error
	// OR
	audioElement.src = sourceElement.buffer;
	// OR
	// audioElement.src = URL.createObjectURL(sourceElement);
	// RESULT: TypeError: URL.createObjectURL: Argument 1 is not valid for any of the 1-argument overloads.
	// OR
	// audioElement.src = sourceElement.toDataURL("audio/mp3");
	// RESULT: TypeError: sourceElement.toDataURL is not a function

	// -------------------

	// Make audioElement visible
	document.getElementById('data_display').appendChild(audioElement);

	// -------------------

	// play audio when page loads
	sourceElement.start(0);

	// -------------------

	await analyse_audioElement(audioContext);
	
	// RESULT: It plays with the button, but not with the audio controls
}

// -----------------------------------------------

async function play_filter_noise_way1() {
	
	const audioElement = await create_an_audioElement();

	// -----------------------------
	
	const [audioContext, WhiteNoise_AudioBuffer, WhiteNoiseData_TypeArray] = await create_audio_data();
	// WhiteNoise_AudioBuffer:  AudioBuffer { sampleRate: 48000, length: 96000, duration: 2, numberOfChannels: 2 }
	// WhiteNoiseData_TypeArray: buffer, byteLength, byteOffset, length
	
	// -----------------------------
	
	// Convert audio data array to ASCII_str
	const [ASCII_str, base64_string] = await convert_Float32Array_to_ASCII_str(WhiteNoiseData_TypeArray)
	
	// Add the audio header on the string, so the audioElement can understand
	const header_base64_string = 'data:audio\/mpeg;base64,'+base64_string;

	var url = await fetch(header_base64_string)
		.then(response => response.blob())
		.then(async function(blob_object) {
			console.log('blob_object: ', blob_object)
			return URL.createObjectURL(blob_object);
		});
	console.log('url: ', url);
	// RESULT: Media resource blob:https://codesolutions2.github.io/16be201d-b21b-4953-83ed-fbfa201c4bdd could not be decoded, error: Error Code: NS_ERROR_DOM_MEDIA_METADATA_ERR (0x806e0006)

	// OR
	
	// const blob_object = new Blob([WhiteNoise_ArrayBuffer], {type: "audio/mp3"});
	// const blob_object = await new Blob([whiteNoiseData_TypeArray], {type: "audio/mp3"})
	// var url = await URL.createObjectURL(blob_object);
	// RESULT: Media resource blob:https://codesolutions2.github.io/16be201d-b21b-4953-83ed-fbfa201c4bdd could not be decoded, error: Error Code: NS_ERROR_DOM_MEDIA_METADATA_ERR (0x806e0006)

	// -----------------------------
	
	audioElement.src = url;

	// -----------------------------
	
	document.getElementById('data_display').appendChild(audioElement);
	
	// -----------------------------
}






	

// -----------------------------------------------
// SUBFUNCTIONS
// -----------------------------------------------
	
async function create_an_audioElement() {

	// Create an AudioElement
	const audioElement = document.createElement('audio');
	// OR
	// const audioElement = new Audio();
	
	audioElement.setAttribute("controls", true);
	audioElement.setAttribute('crossOrigin', "anonymous"); // OR "anonymous"
	audioElement.setAttribute('autoplay', true);
	audioElement.setAttribute('preload', "auto");

	// https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/volume
	audioElement.volume = 0.1; 

	return audioElement;
}

// ----------------------------------------------------

async function create_audio_data() {

	const audioContext = new AudioContext();
	// default audioContext.sampleRate is 48000, a common value is 44100

	// -------------------
	
	// Transform audiodata into correct format for source.buffer
	// https://developer.mozilla.org/en-US/docs/Web/API/BaseAudioContext/createBufferSource
	const duration_seconds = 1 * 60 * 60; // set for 1 hour
	
	// -------------------

	// Create an arrayBuffer
	const channels = 2; 
	const frameCount = audioContext.sampleRate * duration_seconds; // sample_length
	const sampleRate = audioContext.sampleRate; // sample_rate
	const WhiteNoise_AudioBuffer = audioContext.createBuffer(channels, frameCount, sampleRate);
	
	for (let channel=0; channel<channels; channel++) {
		
		// Fill the buffer with audio data per channel
		const channelData_AudioBuffer = WhiteNoise_AudioBuffer.getChannelData(channel);
	
		// One knows the length of channelData_test because of the designated sample_length and sample_rate
		// frameCount OR channelData_AudioBuffer.length
		for (let i = 0; i < channelData_AudioBuffer.length; i++) {
			channelData_AudioBuffer[i] = Math.random() * 2 - 1; // Generate random values between -1 and 1
		}
	}
	console.log('WhiteNoise_AudioBuffer: ', WhiteNoise_AudioBuffer);

	// -------------------
	
	// Make a TypedArray with only one channel
	const WhiteNoiseData_TypeArray = new Float32Array(audioContext.sampleRate);
	
	for (let i = 0; i < WhiteNoiseData_TypeArray.length; i++) {
	    WhiteNoiseData_TypeArray[i] = Math.random() * 2 - 1; // Generate random values between -1 and 1
	}
	console.log('WhiteNoiseData_TypeArray: ', WhiteNoiseData_TypeArray);

	// -------------------
	
	return [audioContext, WhiteNoise_AudioBuffer, WhiteNoiseData_TypeArray];
}
	
// -----------------------------------------------

async function analyse_audioElement(audioContext) {

	// Create an AnalyserNode
	const analyserNode = audioContext.createAnalyser();
	console.log('analyserNode: ', analyserNode);

	let channels = analyserNode.channelCount; // 2
	let time_length = analyserNode.context.currentTime; // 354.976
	
	let fs = analyserNode.context.sampleRate; // 48000
	
	var time_sample = 1/fs; // every time_sample there is a data point, 0.000020833333333333333
	console.log('time_sample: ', time_sample);

	// **** not a correct value = 0
	const data_point_length = time_length // time_sample;  // frameCount, 16992000
	console.log('data_point_length: ', data_point_length);
}

// -----------------------------------------------

async function convert_Float32Array_to_ASCII_str(Float32Array) {
	
	// Convert TypedArray to normalArray
	// const normalArray = await Array.from(Float32Array.data);
	const normalArray = await Array.from(Float32Array);
	// console.log('normalArray: ', normalArray)
	
	// Convert [normalArray of bytes] to text_characters
	var ASCII_stringArray = normalArray.map((val) => { return String.fromCharCode(val); });
	// console.log('ASCII_stringArray: ', ASCII_stringArray);
	
	// Join all the ASCII characters to form a string
	var ASCII_str = ASCII_stringArray.join('');
	// console.log("ASCII_str: ", ASCII_str);
	
	// Transform ASCII string into a base64 string
	var base64_string = btoa(ASCII_str);
	// console.log("base64_string: ", base64_string);

	// -----------------------------

	return [ASCII_str, base64_string];
}

// -----------------------------------------------

	

</script>
</body>
</html>
