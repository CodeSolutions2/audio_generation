<!DOCTYPE html>
<html>
<head></head>
<body>


<label for="select_dropdown_option_label">Select a choice:</label>
<select name="dropdown_options" id="dropdown_options" style="display:block">
  <option value="---">Select an option</option>
  <option value="create_dynamic_canvasElement">create_dynamic_canvasElement</option>
  <option value="create_a_solid_image">create_a_solid_image</option>
  <option value="resize">resize</option>
  <option value="Image_CORS">Image_CORS</option>
  <option value="filter0">filter0</option>
</select>


<input type="text" name="width_NEW" id="width_NEW" value="" style="display:none;">
<input type="text" name="height_NEW" id="height_NEW" value="" style="display:none;">

<input type="text" name="url" id="url" value="" style="display:none;">

<button id="run_selection" onclick="run_selection()">run_selection</button>


<div id="data_display" style="display:block; text-align: left; width: 600px;"></div>
<br>
<div id="notification"></div>


<!-- ---------------------------------------- -->
	
<style>
div#notification { position: relative; color: #3236a8; }
</style>

<!-- ---------------------------------------- -->
	
<script>


// -------------------------------------------------

window.addEventListener('beforeunload', function() {
	window.location.href = window.location.href + '?nocache=' + new Date().getTime();
	document.getElementById("dropdown_options").selectedIndex = 0;
});

// -------------------------------------------------
	
async function processEvent_dropdown_options(event) {
	
	if (document.getElementById("dropdown_options").selectedIndex == 3) {
		document.getElementById("width_NEW").style.display = 'block';
		document.getElementById("height_NEW").style.display = 'block';
		
	} else if (document.getElementById("dropdown_options").selectedIndex == 4) {
		document.getElementById("url").style.display = 'block';
  } else if (document.getElementById("dropdown_options").selectedIndex == 5) {
		document.getElementById("url").style.display = 'block';
	} else {
		document.getElementById("width_NEW").style.display = 'none';
		document.getElementById("height_NEW").style.display = 'none';
		document.getElementById("url").style.display = 'none';
	}
	
}

document.getElementById("dropdown_options").addEventListener("change", processEvent_dropdown_options, false);
	
// -------------------------------------------------

var canvasElement;
var ctx;

var width_ORG = 256;
var height_ORG = 256;

// -------------------------------------------------
	
async function run_selection() {
	
	// Put in a function in <script>
	var dropdown_option_type = document.getElementById("dropdown_options").value;

	if (dropdown_option_type == 'create_dynamic_canvasElement') {
		[ctx, canvasElement] = await create_dynamic_canvasElement("canvasElement_id", "canvasElement_className", canvas_number=0);
		
		// Add the canvas to the DOM
		document.getElementById('data_display').appendChild(canvasElement);
		
	} else if (dropdown_option_type == 'create_a_solid_image') {
		await create_a_solid_image();

	} else if (dropdown_option_type == 'resize') {
		await resize();

	} else if (dropdown_option_type == 'Image_CORS') {
		[ctx, canvasElement] = await create_dynamic_canvasElement("canvasElement_id", "canvasElement_className", canvas_number=0);
		
		// Add the canvas to the DOM
		document.getElementById('data_display').appendChild(canvasElement);
		await Image_CORS(document.getElementById("url").value);

	} else if (dropdown_option_type == 'filter0') {
		[ctx, canvasElement] = await create_dynamic_canvasElement("canvasElement_id", "canvasElement_className", canvas_number=0);
		
		// Add the canvas to the DOM
		document.getElementById('data_display').appendChild(canvasElement);
		await Image_CORS(document.getElementById("url").value);
		await filter_image();
		
	} else {
		document.getElementById("notification") = "No dropdown type selected";
	}


}

// -------------------------------------------------


	
// -------------------------------------------------
// IMAGE SUBFUNCTIONS
// -------------------------------------------------
async function create_dynamic_canvasElement(canvasElement_id, canvasElement_className, canvas_number=0) {
  
	// Create a canvas element
	var canvasElement = document.createElement('canvas');

	// Set attributes of the canvas
	canvasElement.width = width_ORG;
	canvasElement.height = height_ORG;
  	canvasElement.id = canvasElement_id;
	canvasElement.class = canvasElement_className;
	
	// Get the 2D rendering context of the canvas
	var ctx = canvasElement.getContext("2d");

	// -------------------------

	// (Optional) Parameter to put canvas next to each other
	if (canvas_number == 0) {
		canvasElement.style.left = 40+'px';
	} else {
		// Append a canvas to the right of an existing canvas
		let tot = canvas_number*canvasElement.width + 40;
		canvasElement.style.left = tot+'px';
	}

	// -------------------------

	// Make a canvas border
	canvasElement.style.border = '1px solid black';

	return [ctx, canvasElement];
}

// -------------------------------------------------
	
async function create_a_solid_image() {
  // -------------------------
  // Color the canvas
  var r = Math.floor(Math.random()*255);
	var g = Math.floor(Math.random()*255);
  	var b = Math.floor(Math.random()*255);
  	const alpha = Math.floor(Math.random()*100);
  
  	// ----------------------
  
  	// Make r, g, b and interesting color range.
	// Make r from 1 to 255 if r>1, then output=r else output=1
	r = r>0 ? r : 1;
	g = g>0 ? g : 1;
	b = b>0 ? b : 1;

	// ----------------------
	
	ctx.fillStyle = `rgb(${r} ${g} ${b} / ${alpha}%)`;
	ctx.fillRect(0, 0, canvasElement.width, canvasElement.height);
}

// -------------------------------------------------
	
async function resize() {

	// Use src, resize canvas, make new image

	// [0] get copy of original canvas image
	var url = canvasElement.toDataURL('image/png');  // WORKS
	console.log('url: ', url);
		
	// [1] define resizing parameters
	const width_NEW = document.getElementById("width_NEW").value;
	const height_NEW = document.getElementById("height_NEW").value;
	
	var sx = 0; // for cropping the image: distance from the [original left edge of the image] to the [deisred left edge of image]
	var sy = 0; // for cropping the image: distance from the [original top edge of the image] to the [deisred top edge of image]
	var image_width = width_ORG; // width_NEW; // for cropping the image: desired image width
	var image_height = height_ORG; // height_NEW; // for cropping the image: desired image height
	var dx = 0;  // location to place image on canvas: distance from the [left edge of the canvas] to the [left edge of image]
	var dy = 0;  // location to place image on canvas: distance from the [top edge of the canvas] to the [top edge of image]
	var dWidth = width_NEW; // for resizing the image on the canvas: desired image width on canvas
	var dHeight = height_NEW; // for resizing the image on the canvas: desired image width on canvas

	const imageElement = new Image();
	imageElement.crossOrigin = "anonymous";
	imageElement.onload = async () => {

		// [2] resize canvas
		canvasElement.width = width_NEW;
		canvasElement.height = height_NEW;

		// [3] put the image back onto the canvas at the new size using image.src and defining the new size
		ctx.drawImage(imageElement, sx, sy, image_width, image_height, dx, dy, dWidth, dHeight); // only imageElement, sx, sy, image_width, image_height need to be set
	};
	imageElement.src = url;
	
}

// -------------------------------------------------

async function Image_CORS(url) {
  
	const imageElement = new Image();  // image is 'HTMLImageElement'
	imageElement.setAttribute('crossOrigin', "anonymous");
	imageElement.setAttribute('headers', {"Content-Type": "application/json", "Access-Control-Allow-Origin": "*"});
	imageElement.onload = async () => { 
		ctx.drawImage(imageElement, 0, 0, canvasElement.width, canvasElement.height); 
	};
	imageElement.src = url;
}

// -------------------------------------------------

async function filter_image() {

	// Obtain image from canvas
	const normalArray = await convert_canvas_into_ImageData(ctx, canvasElement);

	// ----------------------
	
	// Convert the image to grayscale
	const grayscale_normalArray = await convert_to_grayscale(normalArray);
	console.log('grayscale_normalArray: ', grayscale_normalArray);

	// View result
	[ctx1, canvasElement1] = await create_dynamic_canvasElement("canvasElement1_id", "canvasElement1_className", 1);
	document.getElementById('data_display').appendChild(canvasElement1);
	const grayscale_typedarray = await new Uint8ClampedArray(grayscale_normalArray);
	var grayscale_imageData = await new ImageData(grayscale_typedarray, canvasElement1.width, canvasElement1.height);
	ctx1.putImageData(grayscale_imageData, 0, 0);

	// Check if the canvas is filled
	const result1 = await check_if_canvas_is_filled(ctx1, canvasElement1);
	
	// ----------------------
	
	// "Invert"/threshold the pixels (make pixel values 0 to 254 equal 0, 255)
	const inverted_normalArray = await bitwise_not(normalArray);
	console.log('inverted_normalArray: ', inverted_normalArray);

	// View result
	[ctx2, canvasElement2] = await create_dynamic_canvasElement("canvasElement2_id", "canvasElement2_className", 2);
	document.getElementById('data_display').appendChild(canvasElement2);
	const inverted_typedarray = await new Uint8ClampedArray(inverted_normalArray);
	var inverted_imageData = await new ImageData(inverted_typedarray, canvasElement2.width, canvasElement2.height);
	ctx2.putImageData(inverted_imageData, 0, 0);

	// Check if the canvas is filled
	const result2 = await check_if_canvas_is_filled(ctx2, canvasElement2);

	// ----------------------
	
	// Blur the inverted image (GaussianBlur)
	[ctx3, canvasElement3] = await create_dynamic_canvasElement("canvasElement3_id", "canvasElement3_className", 3);
	document.getElementById('data_display').appendChild(canvasElement3);
	var inverted_imageData = await new ImageData(inverted_typedarray, canvasElement3.width, canvasElement3.height);
	ctx3.putImageData(inverted_imageData, 0, 0);
	
	canvasElement3.style.filter = 'blur(4px)';
	const blurred_normalArray = await convert_canvas_into_ImageData(ctx3, canvasElement3);

	// Check if the canvas is filled
	const result3 = await check_if_canvas_is_filled(ctx3, canvasElement3);

	// ----------------------
  
	// Blend/combine the grayscale and blurred image, to obtain [edges in the image] against a white background
	const blend_normalArray = await blend_ratio_of_pixels(grayscale_normalArray, blurred_normalArray);
	console.log('blend_normalArray: ', blend_normalArray);

	const blend_typedarray = await new Uint8ClampedArray(blend_normalArray);
	let imageData_blend = await new ImageData(blend_typedarray, width_ORG, height_ORG);

	// Make a third canvas
	const [ctx4, canvasElement4] = await create_dynamic_canvasElement("canvasElement4_id", "canvasElement4_className", 4);
	document.getElementById('data_display').appendChild(canvasElement4);
	ctx4.putImageData(imageData_blend, 0, 0);

	// Check if the canvas is filled
	const result4 = await check_if_canvas_is_filled(ctx4, canvasElement4);
	
	// ----------------------
  
}

// -------------------------------------------------

async function convert_canvas_into_ImageData(ctx, canvasElement) {
	
	// Get canvas image
	const uint8ClampedArray = await ctx.getImageData(0, 0, canvasElement.width, canvasElement.height); // TypedArray  Uint8ClampedArray
	// console.log('uint8ClampedArray: ', uint8ClampedArray);
  
	// Convert TypedArray to normalArray
	return normalArray = await Array.from(uint8ClampedArray.data);
}

// -------------------------------------------------

async function convert_to_grayscale(normalArray) {

	// Assign each pixel the average r,g,b pixel value.
	const color_name = ['r', 'g', 'b', 'alpha'];
	for ( let i=0; i<normalArray.length; i+=color_name.length ) {
		  // Calculate the average r, g, b pixel value per pixel
			var rgb_pixel_arr = [normalArray[i], normalArray[i+1], normalArray[i+2]];
      var rbg_pixel_avg = await rgb_pixel_arr.reduce((accumulator, currentValue) => accumulator + currentValue, 0) / rgb_pixel_arr.length;
		  normalArray[i] = rbg_pixel_avg;
      normalArray[i+1] = rbg_pixel_avg;
      normalArray[i+2] = rbg_pixel_avg
	}
	return normalArray;
}

// -------------------------------------------------

async function bitwise_not(normalArray) {

	// Threshold the pixel values to 0 or 255.
	const color_name = ['r', 'g', 'b', 'alpha'];
	for ( let i=0; i<normalArray.length; i+=color_name.length ) {
		  normalArray[i] = normalArray[i] == 255 ? 255 : 0;
      normalArray[i+1] = normalArray[i+1] == 255 ? 255 : 0;
      normalArray[i+2] = normalArray[i+2] == 255 ? 255 : 0;
	}
	return normalArray;
}

// -------------------------------------------------

async function blend_ratio_of_pixels(grayscale, blurred) {

  var output = grayscale;
  
	// Threshold the pixel values to 0 or 255.
	const color_name = ['r', 'g', 'b', 'alpha'];
	for ( let i=0; i<output.length; i+=color_name.length ) {
		  output[i] = ( grayscale[i]/(255-blurred[i]) ) * 256;
		  output[i+1] = ( grayscale[i+1]/(255-blurred[i+1]) ) * 256;
		  output[i+2] = ( grayscale[i+2]/(255-blurred[i]) ) * 256;
	}
	return output;
}
  
// -------------------------------------------------
  
async function check_if_canvas_is_filled(ctx, canvasElement) {
	
	// Get canvas image
	const normalArray = await convert_canvas_into_ImageData(ctx, canvasElement);

	// ----------------------
	
	// A blank canvas has rgb values that are zero.
	// Modify some of the pixels, to determine if there is a change
	const color_name = ['r', 'g', 'b', 'alpha'];
	var r_sum = 0;
	var g_sum = 0;
	var b_sum = 0;
	for ( let i=0; i<normalArray.length; i+=color_name.length ) {
		r_sum = r_sum + normalArray[i];
		g_sum = g_sum + normalArray[i+1];
		b_sum = b_sum + normalArray[i+2];
	}
	console.log("r_sum: ", r_sum);
	console.log("g_sum: ", g_sum);
	console.log("b_sum: ", b_sum);
	var result0 = (r_sum + g_sum + b_sum) == 0 ? 'blank' : 'filled';
	console.log("result0: ", result0);

	// ----------------------

	// Outputs "filled" if there is an image on the canvas, outputs "blank" if the canvas is empty.
  	return result0;
}

// -------------------------------------------------
	
	
</script>
</body>
</html>
